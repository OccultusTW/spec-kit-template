````markdown
---
description: 從自然語言功能描述建立或更新功能規格。
handoffs: 
  - label: 建立技術計劃
    agent: speckit.plan
    prompt: 為規格建立計劃。我正在建構...
  - label: 釐清規格需求
    agent: speckit.clarify
    prompt: 釐清規格需求
    send: true
---

## 使用者輸入

```text
$ARGUMENTS
```

在繼續之前，您**必須**考慮使用者輸入（如果不為空）。

## 大綱

使用者在觸發訊息中在 `/speckit.specify` 後輸入的文字**就是**功能描述。假設您在此對話中始終可以使用它，即使 `$ARGUMENTS` 在下面顯示為字面值。除非他們提供空命令，否則不要要求使用者重複。

給定該功能描述，執行以下操作：

1. **生成簡潔的短名稱**（2-4 個字）用於分支：
   - 分析功能描述並提取最有意義的關鍵字
   - 建立一個 2-4 個字的短名稱來捕捉功能的本質
   - 盡可能使用動作-名詞格式（例如「add-user-auth」、「fix-payment-bug」）
   - 保留技術術語和縮寫（OAuth2、API、JWT 等）
   - 保持簡潔但具有足夠的描述性以便一目了然地理解功能
   - 範例：
     - 「我想添加使用者認證」→「user-auth」
     - 「為 API 實作 OAuth2 整合」→「oauth2-api-integration」
     - 「建立分析儀表板」→「analytics-dashboard」
     - 「修復付款處理超時錯誤」→「fix-payment-timeout」

2. **在建立新分支之前檢查現有分支**：
   
   a. 首先，取得所有遠端分支以確保我們擁有最新資訊：
      ```bash
      git fetch --all --prune
      ```
   
   b. 尋找短名稱在所有來源中的最高功能編號：
      - 遠端分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - Specs 目錄：檢查符合 `specs/[0-9]+-<short-name>` 的目錄
   
   c. 確定下一個可用編號：
      - 從所有三個來源提取所有編號
      - 找到最高編號 N
      - 為新分支編號使用 N+1
   
   d. 使用計算的編號和短名稱執行腳本 `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"`：
      - 與功能描述一起傳遞 `--number N+1` 和 `--short-name "your-short-name"`
      - Bash 範例：`.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 範例：`.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`
   
   **重要**：
   - 檢查所有三個來源（遠端分支、本地分支、specs 目錄）以找到最高編號
   - 只符合具有確切短名稱模式的分支/目錄
   - 如果沒有找到具有此短名稱的現有分支/目錄，從編號 1 開始
   - 您每個功能只能執行此腳本一次
   - JSON 在終端機中作為輸出提供 - 始終參考它以獲取您正在尋找的實際內容
   - JSON 輸出將包含 BRANCH_NAME 和 SPEC_FILE 路徑
   - 對於參數中的單引號（如 "I'm Groot"），使用轉義語法：例如 'I'\''m Groot'（或盡可能使用雙引號："I'm Groot"）

3. 載入 `.specify/templates/spec-template.md` 以了解所需部分。

4. 遵循此執行流程：

    1. 從輸入解析使用者描述
       如果為空：錯誤「未提供功能描述」
    2. 從描述中提取關鍵概念
       識別：參與者、動作、資料、限制
    3. 對於不清楚的方面：
       - 根據背景和行業標準進行有根據的猜測
       - 僅在以下情況下使用 [需要釐清：特定問題] 標記：
         - 選擇顯著影響功能範圍或使用者體驗
         - 存在多種合理的詮釋，具有不同的含義
         - 不存在合理的預設值
       - **限制：最多 3 個 [需要釐清] 標記**
       - 按影響優先處理釐清：範圍 > 安全性/隱私 > 使用者體驗 > 技術細節
    4. 填寫使用者情境與測試部分
       如果沒有清晰的使用者流程：錯誤「無法確定使用者情境」
    5. 生成功能需求
       每個需求必須可測試
       對未指定的細節使用合理的預設值（在假設部分記錄假設）
    6. 定義成功標準
       建立可衡量的、技術無關的結果
       包括量化指標（時間、效能、容量）和質化措施（使用者滿意度、任務完成）
       每個標準必須在沒有實作細節的情況下可驗證
    7. 識別關鍵實體（如果涉及資料）
    8. 返回：成功（規格準備計劃）

5. 使用模板結構將規格寫入 SPEC_FILE，用從功能描述（參數）派生的具體細節替換佔位符，同時保留部分順序和標題。

6. **規格品質驗證**：在撰寫初始規格後，根據品質標準進行驗證：

   a. **建立規格品質檢查清單**：使用檢查清單模板結構在 `FEATURE_DIR/checklists/requirements.md` 生成檢查清單檔案，包含這些驗證項目：

      ```markdown
      # 規格品質檢查清單：[功能名稱]
      
      **目的**：在進行計劃之前驗證規格的完整性和品質
      **建立日期**：[日期]
      **功能**：[連結到 spec.md]
      
      ## 內容品質
      
      - [ ] 無實作細節（語言、框架、API）
      - [ ] 專注於使用者價值和業務需求
      - [ ] 為非技術利益相關者撰寫
      - [ ] 所有必填部分完成
      
      ## 需求完整性
      
      - [ ] 沒有 [需要釐清] 標記保留
      - [ ] 需求可測試且明確
      - [ ] 成功標準可衡量
      - [ ] 成功標準與技術無關（無實作細節）
      - [ ] 所有驗收情境已定義
      - [ ] 邊界情況已識別
      - [ ] 範圍明確界定
      - [ ] 依賴關係和假設已識別
      
      ## 功能就緒性
      
      - [ ] 所有功能需求都有明確的驗收標準
      - [ ] 使用者情境涵蓋主要流程
      - [ ] 功能符合成功標準中定義的可衡量結果
      - [ ] 無實作細節洩漏到規格中
      
      ## 註釋
      
      - 標記為未完成的項目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新規格
      ```

   b. **執行驗證檢查**：根據每個檢查清單項目檢視規格：
      - 對於每個項目，確定它是通過還是失敗
      - 記錄找到的特定問題（引用相關的規格部分）

   c. **處理驗證結果**：

      - **如果所有項目都通過**：標記檢查清單完成並繼續執行步驟 6

      - **如果項目失敗（不包括 [需要釐清]）**：
        1. 列出失敗的項目和特定問題
        2. 更新規格以解決每個問題
        3. 重新執行驗證直到所有項目通過（最多 3 次迭代）
        4. 如果在 3 次迭代後仍然失敗，在檢查清單註釋中記錄剩餘問題並警告使用者

      - **如果 [需要釐清] 標記保留**：
        1. 從規格中提取所有 [需要釐清：...] 標記
        2. **限制檢查**：如果存在超過 3 個標記，只保留最關鍵的 3 個（按範圍/安全性/UX 影響）並對其餘部分進行有根據的猜測
        3. 對於每個需要釐清的項目（最多 3 個），以此格式向使用者呈現選項：

           ```markdown
           ## 問題 [N]：[主題]
           
           **背景**：[引用相關的規格部分]
           
           **我們需要知道的**：[來自需要釐清標記的特定問題]
           
           **建議答案**：
           
           | 選項 | 答案 | 含義 |
           |------|------|------|
           | A    | [第一個建議答案] | [這對功能意味著什麼] |
           | B    | [第二個建議答案] | [這對功能意味著什麼] |
           | C    | [第三個建議答案] | [這對功能意味著什麼] |
           | 自訂 | 提供您自己的答案 | [解釋如何提供自訂輸入] |
           
           **您的選擇**：_[等待使用者回應]_
           ```

        4. **關鍵 - 表格格式**：確保 markdown 表格格式正確：
           - 使用一致的間距，管道對齊
           - 每個儲存格內容周圍應有空格：`| 內容 |` 而不是 `|內容|`
           - 標題分隔符必須至少有 3 個破折號：`|--------|`
           - 測試表格在 markdown 預覽中正確呈現
        5. 按順序編號問題（Q1、Q2、Q3 - 最多 3 個）
        6. 在等待回應之前一起呈現所有問題
        7. 等待使用者回應所有問題的選擇（例如「Q1：A、Q2：自訂 - [詳細資訊]、Q3：B」）
        8. 透過用使用者選擇或提供的答案替換每個 [需要釐清] 標記來更新規格
        9. 在解決所有釐清後重新執行驗證

   d. **更新檢查清單**：在每次驗證迭代後，使用當前的通過/失敗狀態更新檢查清單檔案

7. 報告完成情況，包括分支名稱、規格檔案路徑、檢查清單結果以及下一階段（`/speckit.clarify` 或 `/speckit.plan`）的就緒性。

**注意：**腳本在撰寫之前建立並檢出新分支並初始化規格檔案。

## 一般指南

## 快速指南

- 專注於**什麼**使用者需要和**為什麼**。
- 避免**如何**實作（無技術堆疊、API、程式碼結構）。
- 為業務利益相關者撰寫，而不是開發人員。
- 不要建立嵌入在規格中的任何檢查清單。那將是一個單獨的命令。

### 部分需求

- **必填部分**：必須為每個功能完成
- **可選部分**：僅在與功能相關時包含
- 當部分不適用時，完全刪除它（不要留為「N/A」）

### 對於 AI 生成

從使用者提示建立此規格時：

1. **進行有根據的猜測**：使用背景、行業標準和常見模式來填補空白
2. **記錄假設**：在假設部分記錄合理的預設值
3. **限制釐清**：最多 3 個 [需要釐清] 標記 - 僅用於關鍵決策：
   - 顯著影響功能範圍或使用者體驗
   - 有多種合理的詮釋，具有不同的含義
   - 缺乏任何合理的預設值
4. **優先處理釐清**：範圍 > 安全性/隱私 > 使用者體驗 > 技術細節
5. **像測試人員一樣思考**：每個模糊的需求都應該無法通過「可測試且明確」的檢查清單項目
6. **需要釐清的常見領域**（僅在不存在合理預設值時）：
   - 功能範圍和邊界（包括/排除特定用例）
   - 使用者類型和權限（如果可能有多種衝突的詮釋）
   - 安全性/合規性需求（在法律/財務上很重要時）

**合理預設值的範例**（不要詢問這些）：

- 資料保留：領域的行業標準實踐
- 效能目標：除非另有說明，否則為標準網頁/行動應用程式期望
- 錯誤處理：使用者友善的訊息，具有適當的後備
- 認證方法：網頁應用程式的標準基於會話或 OAuth2
- 整合模式：除非另有說明，否則為 RESTful API

### 成功標準指南

成功標準必須：

1. **可衡量**：包括特定指標（時間、百分比、計數、比率）
2. **技術無關**：不提及框架、語言、資料庫或工具
3. **以使用者為中心**：從使用者/業務角度描述結果，而不是系統內部
4. **可驗證**：可以在不知道實作細節的情況下測試/驗證

**好的範例**：

- 「使用者可以在 3 分鐘內完成結帳」
- 「系統支援 10,000 個並發使用者」
- 「95% 的搜尋在 1 秒內返回結果」
- 「任務完成率提高 40%」

**壞的範例**（以實作為中心）：

- 「API 回應時間低於 200ms」（太技術性，使用「使用者立即看到結果」）
- 「資料庫可以處理 1000 TPS」（實作細節，使用面向使用者的指標）
- 「React 元件高效呈現」（框架特定）
- 「Redis 快取命中率高於 80%」（技術特定）

````